#如何分析一个“排序算法”？
是否为原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

#稳定性：
这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。
比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。
这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作稳定的排序算法；
如果前后顺序发生变化，那对应的排序算法就叫作不稳定的排序算法。

#冒泡排序
1)冒泡排序空间复杂度是O(1)，是原地排序算法。
2)冒泡排序是稳定的排序算法。
3)冒泡排序最好情况时间复杂度是O(n)。
4)冒泡排序最坏情况时间复杂度为O(n2)。

#插入排序
1)插入排序空间复杂度是O(1)，是原地排序算法。
2)插入排序是稳定的排序算法。
3)插入排序最好情况时间复杂度是O(n)。
4)插入排序最坏情况时间复杂度为O(n2)。

#选择排序
1)选择排序空间复杂度为O(1)，是一种原地排序算法。
2)选择排序是一种不稳定的排序算法。（选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。）
3)选择排序空间复杂度为O(1)，是一种原地排序算法。
4)选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为O(n2)。

#冒泡排序和插入排序的时间复杂度都是 O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？
冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，而插入排序只需要1个。

#归并排序
1)归并排序空间复杂度为O(n)，不是原地排序算法（临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)）。
2)归并排序是一种稳定的排序算法。
3)归并排序的时间复杂度是O(nlogn)。

#快速排序
1)快速排序空间复杂度为O(1)，是一种原地排序算法。
2)快速排序是一种不稳定的排序算法。
3)快排的时间复杂度也是O(nlogn)。
4)极端情况下退化：举一个比较极端的例子。如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，
那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。
每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)。
