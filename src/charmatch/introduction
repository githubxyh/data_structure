#主串和模式串：
我们在字符串A中查找字符串B，那字符串A就是主串，字符串B就是模式串。
我们把主串的长度记作n，模式串的长度记作m。因为我们是在主串中查找模式串，所以n>m。

#BF算法
BF 算法是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。
所以，时间复杂度也比较高，是 O(n*m)，n、m 表示主串和模式串的长度。
不过，在实际的软件开发中，因为这种算法实现简单，对于处理小规模的字符串匹配很好用。

#RK算法
RK 算法是借助哈希算法对 BF 算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。
所以，理想情况下，RK 算法的时间复杂度是 O(n)，跟 BF 算法相比，效率提高了很多。
不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。
极端情况下，哈希算法大量冲突，时间复杂度就退化为 O(n*m)。

#BM算法
BM算法包含两部分，分别是坏字符规则（bad character rule）和好后缀规则（good suffix shift）

#坏字符规则：
1.从模式串的末尾往前倒着匹配，当我们发现某个字符没法匹配的时候。我们把这个没有匹配的字符叫作坏字符（主串中的字符）。
2.如果坏字符c在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符c与模式串中的任何字符都不可能匹配。
3.这个时候，我们可以将模式串直接往后滑动m(m表示模式串的长度)位，将模式串滑动到c后面的位置，再从模式串的末尾字符开始比较。
4.如果坏字符a在模式串中是存在的，模式串中下标是index的位置也是字符a。
5.这种情况下，我们可以将模式串往后滑动index位，让两个a上下对齐，然后再从模式串的末尾字符开始，重新匹配。

#好后缀规则：
1.第一个匹配到的最长的字符串作好后缀（尽可能匹配多个字符）。
2.比如在acacadcbcbacabc中匹配cbacabc，当匹配到bc时，bc是好后缀，
3.因为cbacabc开头有c，所以不能将cbacabc直接移动到主串的bc之后，只能移动到主串的b之后。避免移动过头。


